import { Scheduler } from "scheduler.js";

function computeCounts(ns, target, hackThreads, hackFraction) {
    let hackTime = ns.getHackTime(target);
    let growTime = ns.getGrowTime(target);
    let weakenTime = ns.getWeakenTime(target);

    let growThreads = Math.ceil(ns.growthAnalyze(target, 1.06) * growTime / hackTime);
    // Note: weaken weakens the security level by 0.05, so we have to multiply the rate of
    // security increases by 20 to get the desired number of threads.
    let weakenThreads = Math.ceil(1.1 * 20 * (0.002 * hackThreads * (weakenTime / hackTime) +
        0.004 * growThreads * (weakenTime / growTime)));
    return {hack: hackThreads, grow: growThreads, weaken: weakenThreads};
}

function ramUsage(ns, threadDict) {
    return ns.getScriptRam("hack.js") * threadDict.hack +
           ns.getScriptRam("grow.js") * threadDict.grow +
           ns.getScriptRam("weaken.js") * threadDict.weaken;
}

function threadsForScript(scheduler, filename) {
    return scheduler.jobs.filter(j => j.filename == filename).map(j => j.threads).reduce((a, n) => a + n, 0);
}

// Calculates ram available, counting ram currently dedicated to hacking as available.
// Depends on the scheduler being synced, so checkIntegrity(true) must be called before this.
function calculateRamAvailable(ns, scheduler) {
    // Total available ram.
    const ram = scheduler.servers.map(s => {
        if (s.hostname != "home") return s.ram;
        return Math.max(0, s.ram - Math.max(0.2 * s.ram, 32));
    }).reduce((a, n) => a + n, 0);
    // Ram used by jobs other than the ones that we schedule.
    const usedOther = scheduler.jobs.map(j => {
        if (["hack.js", "weaken.js", "grow.js"].indexOf(j.filename) >= 0) return 0;
        return j.threads - ns.getScriptRam(j.filename);
    }).reduce((a, n) => a + n, 0);
    // Maximum overhead from our jobs not fitting evenly in the servers.
    const possibleFragmentation = 2 * scheduler.servers.length;
    return ram - usedOther - possibleFragmentation;
}

function decideHackThreads(ns, target, ramAvailable) {
    let oneHackFraction = ns.hackAnalyzePercent(target) / 100;
    // We want to hack up to 5% of the server's money per hack.
    let desiredHackThreads = oneHackFraction === 0 ? 1 : Math.max(1, Math.floor(0.05 / oneHackFraction));
    if (ns.getServerSecurityLevel(target) > 5 + ns.getServerMinSecurityLevel(target)) {
        // If the server's security level is very high, it will return a low fraction. This will result
        // in a high number of hack threads which will cause instability. Instead, we'll cap the number of
        // hack threads to a semi-reasonable value. Since we scehdule a slight excess of grow and weaken
        // threads, over time, the server's security level will improve and we'll get a more accurate estimate.
        desiredHackThreads = Math.min(200, desiredHackThreads);
    } else {
        // If we're near the target's minimum security level, we'll scale UP the number of
        // hack threads by the inverse of the hack chance. This has to be recalculated from
        // time to time as our hacking skill increases.
        desiredHackThreads *= Math.floor(1 / ns.hackChance(target));
    }
    return computeCounts(ns, target, desiredHackThreads);
}

class Target {
  constructor(ns, hostname) {
    this.hostname = hostname;
    this.growTime = ns.getGrowTime(hostname);
    this.weakenTime = ns.getWeakenTime(hostname);
    this.hackTime = ns.getHackTime(hostname);
    this.hackChance = ns.hackChance(hostname);
    this.hackFraction = ns.hackAnalyzePercent(hostname) / 100;
    this.maxMoney = ns.getServerMaxMoney(hostname);
    this.money = ns.getServerMoneyAvailable(hostname);
    this.currentSecurity = ns.getServerSecurityLevel(hostname);
    this.minSecurity = ns.getServerMinSecurityLevel(hostname);
  }
}

// Returns the rational number of weaken threads required to dissipate the security generated by threadDict on target,
// including a slack factor.
function requiredWeakenThreads(threadDict, target) {
  const weakenRatePerThread = 0.05 / target.weakenTime;
  const growSecurityPerSec = threadDict.grow * (1 / target.growTime) * 0.004;
  const hackSecurityPerSec = threadDict.hack * (1 / target.hackTime) * 0.002;
  const totalReqdDissipationPerSec = growSecurityPerSec + hackSecurityPerSec;
  const slackFraction = 1.5;
  return slackFraction * totalReqdDissipationPerSec / weakenRatePerThread;
}

// Returns the rational number of growth threads rqeuired to offset a given number of hack threads. We include a
// slack factor to allow for variance in the actual performance over the duration the job is scheduled.
function requiredGrowThreads(ns, threadDict, target) {
  const hackedFractionDuringGrowDuration =
      target.hackChance * target.hackFraction * threadDict.hack * target.growTime / target.hackTime;
  const slackFraction = 1.5;
  return ns.growthAnalyze(target.hostname, 1 + hackedFractionDuringGrowDuration * slackFraction);
}

// Up until this point, we calculate all threads as rational numbers. This function makes those values integral,
// and scales them to the amount of ram available. It also ensures that, after scaling, we have not inadvertently
// created a situation where security gradually increases or money available gradually decreases.
function makeFit(ns, threadDict, ramAvailable, target) {
  const ram = ramUsage(ns, threadDict);
  if (ram > ramAvailable) {
    const scale = ramAvailable / ram;
    threadDict.hack *= scale;
    threadDict.grow *= scale;
    threadDict.weaken *= scale;
  }
  threadDict.hack = Math.floor(threadDict.hack);
  threadDict.grow = Math.floor(threadDict.grow);
  threadDict.weaken = Math.floor(threadDict.weaken);

  // Iteratively adjust threads until we reach a stable equilibrium. We shouldn't
  // require too many passes here since things will already be nearly correct when
  // the information is passed in.
  const maxIterations = 1000;
  let i = 0;
  for (; i < maxIterations; ++i) {
    const securitySlack = 1;
    if (threadDict.grow > 0 &&
        requiredWeakenThreads(threadDict, target) > threadDict.weaken) {
      --threadDict.grow;
      ++threadDict.weaken;
      continue;
    }
    const growthSlack = 1.1;
    if (threadDict.hack > 0 &&
        requiredGrowThreads(ns, threadDict, target) > threadDict.grow) {
      --threadDict.hack;
      ++threadDict.grow;
      continue;
    }
    // We don't need any ram slack as it is already factored in to the ram available.
    if (ramUsage(ns, threadDict) > ramAvailable) {
      --threadDict.weaken;
      continue;
    }
    break;
  }
  if (i > maxIterations) throw new Error("too many iterations on: " + JSON.stringify(threadDict));
  return threadDict;
}

function decideIdealThreads(ns, target) {
  const securityPerWeaken = 0.05;

  if (target.currentSecurity > target.minSecurity + 10) {
    // Return weakens to consume either all remaining ram, or enough weakens to dissipate all the security in
    // one cycle.
    return {weaken: Math.ceil((target.currentSecurity - target.minSecurity) / securityPerWeaken),
            grow: 0,
            hack: 0};
  }

  // Our security is low enough that we can consider growing.
  if (target.money < target.maxMoney * 0.75) {
    // We're far from the maximum amount of money. Return enough grows to generate 5 security per cycle. We will leave these in place
    // until we're closer to our target. 0.75 is close enough because we schedule an excess of growth threads. Since we grow by 20% extra per
    // cycle, we'll reach max money after two more growth cycles.
    let threadDict = {hack: 0, grow: 5 / 0.004, weaken: 0};
    threadDict.weaken = requiredWeakenThreads(threadDict, target);
    return threadDict;
  }

  // Out money is high enough that we can start hacking. Return enough hack threads to consume about 5% of the server's money per hack,
  // and a corresponding number of grow and weaken threads.
  let threadDict = {hack: ns.hackAnalyzeThreads(target.hostname, target.maxMoney * 0.05), grow: 0, weaken: 0};
  threadDict.grow = requiredGrowThreads(ns, threadDict, target);
  threadDict.weaken = requiredWeakenThreads(threadDict, target);
  return threadDict;
}

// Returns the amount of ram to be used by the scheduled threads required for executing on a single target.
function jobsForTarget(target, threadDict) {
    return [{filename: "weaken.js", args: [target], threads: threadDict.weaken},
            {filename: "grow.js", args: [target], threads: threadDict.grow},
            {filename: "hack.js", args: [target], threads: threadDict.hack}];
}

async function startExtraWeakens(scheduler, weakens) {
    await scheduler.start({filename: "weaken.js", args: ["foodnstuff", "extra_weakens"], threads: weakens});
}

async function stopExtraWeakens(scheduler) {
    await scheduler.stop({filename: "weaken.js", args: ["foodnstuff", "extra_weakens"]});
}

async function computeThreadsForAllTargets(ns, scheduler) {
    let ramAvailable = calculateRamAvailable(ns, scheduler);

    // Order the servers from easiest to hardest to hack. Even though this seems inefficient,
    // it helps get hacking experience up fast, which will in turn lead to faster hacks, more
    // hacking of not-yet-owned servers, and therefore faster mid and long-term money growth.
    let hostAndThreads = [];
    let haveScaledDown = false;
    let hackingLevel = ns.getHackingLevel();
    for (const s of _.orderBy(scheduler.servers, [s => ns.getServerBaseSecurityLevel(s.hostname)], ["asc"])) {
        if (s.hostname == "home" || ns.getServerMaxMoney(s.hostname) < 1000000) {
            continue;
        }
        if (haveScaledDown) {
            // Don't allocate any more threads to lower priority targets if we had to scale down our needs on the targets
            // we have available.
            hostAndThreads.push({target: s.hostname, threadDict: {hack: 0, grow: 0, weaken: 0}});
            continue;
        }
        const target = new Target(ns, s.hostname);
        let threadDict = decideIdealThreads(ns, target);
        if (ramUsage(ns, threadDict) > ramAvailable) {
          haveScaledDown = true;
        }
        threadDict = makeFit(ns, threadDict, ramAvailable, target);
        ramAvailable -= ramUsage(ns, threadDict);
        hostAndThreads.push({
            hackingLevel: hackingLevel,
            target: s.hostname,
            threadDict: threadDict});
    }
    return hostAndThreads;
}

function totalThreadCount(threadDict) { return threadDict.grow + threadDict.weaken + threadDict.hack; }

async function scheduleAllTargets(ns, scheduler) {
    const dbFile = "db_hack_calculator.txt";
    let computed = await computeThreadsForAllTargets(ns, scheduler);
    let last = JSON.parse(ns.read(dbFile) || "[]");

    // We compute the target number of hosts and threads every thirty seconds for every
    // server we can see. However, we also remember what we computed. We only update jobs if:
    // 1. The hack skill value has changed by more than 10% since the last time we last computed
    // 2. The amount of free ram available has changed significantly. (I.e. didReallocateThreads has
    //    changed or growWeakenMultiplier is different.)
    let toUpdate = [];
    _.map(computed, c => {
        const old = _.find(last, o => o.target == c.target);
        if (!old) {
            toUpdate.push(c);
            return c;
        }

        const ct = c.threadDict;
        const ot = old.threadDict;
        // When the hacking level hasn't changed much since we last rescheduled this, we require
        // a large change to induce us to reschedule again. When it's changed by more than a hundred,
        // a small change will do it.
        if (!ot.hackingLevel) ot.hackingLevel = 0;
        const maxIgnoredChange = Math.abs(ct.hackingLevel - ot.hackingLevel) > 100 ? 0.025 : 0.25;

        if (Math.abs(ct.hack - ot.hack) > maxIgnoredChange * ct.hack ||
            Math.abs(ct.grow - ot.grow) > maxIgnoredChange * ct.grow ||
            Math.abs(ct.weaken - ot.weaken) > maxIgnoredChange * ct.weaken) {
            toUpdate.push(c);
            return c;
        }
        // The situtation hasn't changed enough since last time! We're not going to update this job.
        return old;
    });


    let ramAvailable = calculateRamAvailable(ns, scheduler);
    for (const ht of computed) {
        ramAvailable -= ramUsage(ns, ht.threadDict);
    }

    let jobList = [];
    for (const ht of toUpdate) {
        jobList.push(...jobsForTarget(ht.target, ht.threadDict));
    }
    let extraWeakens = Math.floor(0.90 * ramAvailable / ns.getScriptRam("weaken.js"));
    jobList.push({filename: "weaken.js", args: ["foodnstuff", "extra_weakens"], threads: extraWeakens});

    console.log("Updating hack jobs: ", toUpdate);
    await scheduler.scheduleAll(jobList);

    // After the updates are done, we write back the computed hosts and threads.
    ns.write(dbFile, JSON.stringify(computed, undefined, 2), "w");
}

export async function main(ns) {
    ns.disableLog("ALL");
    while (true) {
        let scheduler = new Scheduler(ns);
        await scheduler.beginTransaction();
        await scheduler.checkIntegrity(false);
        try {
            await scheduleAllTargets(ns, scheduler);
        } finally {
            scheduler.maybeCommitTransaction();
        }

        // We want to do updates frequently. Most times, nothing will change and only very light work is done.
        await ns.sleep(45000);
    }
}
